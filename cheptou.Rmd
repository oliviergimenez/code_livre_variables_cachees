---
title: "Des chaines de Markov cachées couplées pour estimer la colonisation et la survie dans une métapopulation de plantes annuelles avec dormance"
author: "P.-O. Cheptou, S. Cordeau, S. Le Coz, N. Peyrard"
output: 
    html_document:
        toc: TRUE
        toc_float: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

```{r}
library('doParallel')
```

# 1. Load and transform data 

## 1.1 Load the original observations for the 7 species of the study

```{r}
set.seed(1)
#Setting the number of states 
#K observable states
K=5
#I hidden states
I=5
```

Getting the raw data for the 7 species of the study (density per square meter)
DATA SET REFERENCE
Cordeau, S., Adeux, G., Meunier, D., Strbik, F., Dugué, F., Busset, H., Vieren, E., Louviot, G., & Munier-Jolain, N. (2020). Weed density of 7 major weeds in the long-term integrated weed management cropping system experiment of Dijon-Epoisses (2000-2017), https://doi.org/10.15454/M5P3LM. Portail Data INRAE.

```{r}
# save(data,file="data_epoisse.Rdata")
load("dat/data_epoisse.Rdata")
# raw data : data[[species]][patch,year]
```


```{r}
dtstate2=list()
oo=1
classS=list()
for(o in 1:7){
  dtstate2[[oo]]=array(rep(0,17*90),dim=c(90,17))
  classS[[oo]]=rep(0,K-2)
  oo=oo+1
}
names(classS)<-names(data)
names(dtstate2)<-names(data)
```


## 1.2 Define the  bounds of the abundance classes of standing flora and transform raw data into abundance classes, for each species 

```{r}
oo=1
size_of_class=rep(0,length(names(dtstate2)))

for( o in names(dtstate2)){
  difference= max(log(data[[o]][which(data[[o]]!=0)]+1))
  interval=difference/4
  size_of_class[oo]=interval
  for(i in 1:90){
    for(j in 1:17){
      
      
      if(data[[o]][i,j]==0){dtstate2[[oo]][i,j]=1
      }else if(log(data[[o]][i,j]+1)<interval){dtstate2[[oo]][i,j]=2}
      else if(log(data[[o]][i,j]+1)<interval*2){dtstate2[[oo]][i,j]=3}
      else if(log(data[[o]][i,j]+1)<interval*3){dtstate2[[oo]][i,j]=4}
      else if(log(data[[o]][i,j]+1)>=interval*3){dtstate2[[oo]][i,j]=5}
      
    }
  }
  oo=oo+1
}
names(size_of_class)<-names(dtstate2)

size_of_class=size_of_class[c("ALOMY","CHEAL","SOLNI",'POLCO','AETCY','GALAP','POLAV')]

size_class_no_log=matrix(rep(0,5*7),nrow=7)
rownames(size_class_no_log)<-c("ALOMY","CHEAL","SOLNI",'POLCO','AETCY','GALAP','POLAV')
for(q in 1:7){
  
  size_class_no_log[q,4]=exp(size_of_class[q]*3-1)
  size_class_no_log[q,3]=exp(size_of_class[q]*2-1)
  size_class_no_log[q,2]=exp(size_of_class[q]-1)
}

size_class_no_log[,5]=rep(10000,7)

# dtstate2 gives the states (abundance class of standing flora) for each species in each patch for each year. 
# dtstate2[[species]][patch,year]
```


```{r}
### Load the data if you didn't run the transformation into abundance classes
# save(dtstate2,file='classes_uniforme_PIC_log(+1).Rdata')
load('dat/classes_uniforme_PIC_log(+1).Rdata')
```


## 1.3 Load the distances between the patches, and the crop types

```{r}
#loading cultd
#cultd gives the crop type for each patch each year between winter and summer.
#1=winter 2=summer 
load('dat/culture_epoisse_binaire.Rdata')

#loading diszon
load('dat/distance_entre_les_patchs.Rdata')

#missing data in patchs 64 and 74
index_patch_with_missing_info=c(64,71)
```


# 2. Compute spatial correlation between patchs (to build the neighbourhood)

You can directly go at the end of step 2 and load the results from Rdata files.

```{r}
diszone2=diszone[-index_patch_with_missing_info,-index_patch_with_missing_info]

correlation_results=list()

for(speci in c("ALOMY","CHEAL","SOLNI",'POLCO','AETCY','GALAP','POLAV')){
  


keepcor=array(rep(0,88*88),dim=c(88,88))
corecol=array(rep(0,88*16*88),dim=c(16,88,88))
nbr=0


data1=data[[speci]][-index_patch_with_missing_info,]

for(k in 1:88){
  corecol[,,k]=t(data1[,2:17])
  corecol[,k,k]=t(data1[k,1:16])
  
  keepcor[k,]=cor(corecol[,,k])[k,]
  
}
for(i in 1:88){
  for(j in 1:88){
    
   
    
    
    if(is.na(keepcor[i,j])){keepcor[i,j]=0}
    
    
    
  }}

for(i in 1:88){
  for(j in 1:88){
    if(i>j){diszone2[i,j]=-1}
  }}

ordr=sort(diszone2)
l=1

corki=list()
k=1

while(l<length(ordr)){
  if(l==1||ordr[l]!=ordr[l-1]){
   
    corki[[k]]=c(0,0)
    leschamps=which(ordr[l]==diszone2,arr.ind=TRUE)
    
    dd=dim(which(ordr[l]==diszone2,arr.ind=TRUE))[1]
   
    cumm=0
    for(oo in 1:dd ){
     
      cumm= keepcor[leschamps[oo,1],leschamps[oo,2]] +cumm + keepcor[leschamps[oo,2],leschamps[oo,1]]
      
    }

    corki[[k]]=c(cumm/(2*dd),ordr[l])
    names(corki[[k]])<-c('mean correlation','between patches distance')
    k=k+1
    
    
  }else{}
  
  l=l+1
  
}
correlation_results[[speci]]<-corki
}
```

