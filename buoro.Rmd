---
title: "Mise évidence des processus éco-évolutifs en milieu naturel : le cas des compromis entre traits d’histoire de vie"
author: "M. Buoro, J. Papaïx, S. Cubaynes"
output: 
    html_document:
        toc: TRUE
        toc_float: TRUE
---

## Case study 1: Coûts de la maturation et la migration pour la survie : une approche théorique

Packages & functions
```{r}
require(rjags)
library(coda)
```

### Data simulation

Parameter values.
```{r}
N=500 # number of individuals
```

Parameters values to simulate evolutionary trade-offs. Le paramètre alpha contrôle le coût de la maturation pour la survie, tandis que le paramètre beta celui du coût de la migration (croissance) pour la survie. Les valeurs correspondent aux valeurs attendus des paramètres à l'échelle du logarithme naturel. Ainsi si ces paramètres ne sont pas différents de 1, il n'y a pas de compromis ; si les coefficients sont inférieurs à 1, il y a un compromis négatif tandis que s'ils sont supérieurs à 1, il y a un compromis positif.

SCENARIO A: cost of maturation and migration for survival
```{r}
ALPHA = 0.3; # cost of maturation for survival
BETA = 0.7; #cost of migration for survival
THETA = c(2, 4.4, -3.25) # THRESHOLDS
```

SCENARIO B: no trade-offs
```{r}
ALPHA = 1 # no cost of maturation for survival
BETA = 1 # no cost of migration for survival
THETA = c(2, 4.4, -2.5) # THRESHOLDS
```

SCENARIO C: cost of maturation for survival and positive effect of migration on survival
```{r}
ALPHA = 0.3 # cost of maturation for survival
BETA =  1.3; # advantage of migration for survival
THETA=c(2, 4.4, -2.75) # THRESHOLDS
```

```{r}
I=array(,dim=c(N,3)); # Binary variables of life history decisions, maturation, migration and survival respectively
X=array(,dim=c(N,2)); # Observable traits (weight and size)
Z=array(,dim=c(N,3)) # Proximate cues (latent variable)
SIGMA=NULL
```

SIZE/WEIGHT RELATIONSHIP
```{r}
mu_X=c(NA,80); # mu_X[2]: average size of individuals
a <- 0.00001;b <- 3 # coeffcients values of the weight-size relationship
SIGMA_X=c(0.2,12) # standard deviation for phenotypes size and weight

X[,2]<-rnorm(N,mu_X[2],SIGMA_X[2]) # Size
mu_X1 <- log(a) + b * log(X[,2]) # weight-size relationship
X[,1] <- rlnorm(N,mu_X1,SIGMA_X[1]) # Weight
```

Décision de maturation
```{r}
SIGMA=c(0.5,0.1) ## residual standard deviation
Z[,1] <- rnorm(N, log(X[,1]),SIGMA[1]) # Reserve status
I[,1] <- ifelse(Z[,1]>=THETA[1], 1, 0)
```

Décision de migration
```{r}
SIGMA=c(0.5,0.1) ## residual variance
Z[,2] <-rnorm(N, log(X[,2]),SIGMA[2]) # Structure status
I[,2] <- ifelse(Z[,2]>=THETA[2], 1, 0)
```

Survie
```{r}
Z[,3]<-(Z[,1] - Z[,2]) + log(ALPHA)*I[,1] + log(BETA)*I[,2]
I[,3] <- ifelse(Z[,3]>=THETA[3], 1, 0)
```

## Data

```{r}
data<-list(
N=N
,Y=I # phenotypes (0/1)
,X=X # observable cues (e.g. weight, size)
)
```

## Model 

```{r}
write("
model {
   for (i in 1:N) {

      ## Proximate cues ##
      Z[i,1]~dnorm(log(X[i,1]), tau[1]) # Reserve
      Z[i,2]~dnorm(log(X[i,2]), tau[2]) # Structure

      ## Maturing decision
      Y[i,1]~dinterval(Z[i,1],THETA[1])

      ## Migration decision:
      Y[i,2]~dinterval(Z[i,2],THETA[2])

      ## Survival:
      Y[i,3]~dinterval(Z[i,1]-Z[i,2] + (log(ALPHA) * Y[i,1]) + (log(BETA) * Y[i,2]),THETA[3])

} # END OF THE LOOP i

  ### PRIORS ####
  ALPHA~dgamma(0.5, 0.5)
  BETA~dgamma(0.5, 0.5)

  ## Thresholds:
  for (j in 1:3){THETA[j]~dnorm(0, 0.001)} # end loop j

  ## Variance
  for (j in 1:2){
    tau[j]<-pow(SIGMA[j],-2) # precision
    SIGMA[j]~dunif(0,100) # sd
  } # end loop j

} # END OF THE MODEL
", "LEAM.R")
```

## Analysis


```{r}
parameters=c("ALPHA","BETA","THETA","SIGMA")

### /!\ Warning: To illustrate, here we use simulated values as initial values.
## but initial values can be generated randomly, they must however be consistent: Z.inits[i] > THETA.inits[i] if Y[i]=1

inits<-function(){
  list(
  'Z'=Z[,1:2]
  ,'THETA'=THETA,
  'ALPHA'=ALPHA,
  'BETA'=BETA,
  'SIGMA'=SIGMA)
  }

nChains = 2 # Number of chains to run.
adaptSteps = 1000 # Number of steps to "tune" the samplers.
burnInSteps = 5000 # Number of steps to "burn-in" the samplers.
numSavedSteps=25000 # Total number of steps in chains to save.
thinSteps=1 # Number of steps to "thin" (1=keep every step).
nPerChain = ceiling( ( numSavedSteps * thinSteps ) / nChains ) # Steps per chain.
```

Compile & adapt
```{r}
### Start of the run ###
start.time = Sys.time(); cat("Start of the run\n");

## Compile & adapt
# Create, initialize, and adapt the model:
jagsfit=jags.model('LEAM.R',data,inits,n.chains=nChains,n.adapt = adaptSteps)

# Burn-in:
cat( "Burning in the MCMC chain…\n" )
#jagsfit$recompile()
update(jagsfit, n.iter=burnInSteps,progress.bar="text")

# The saved MCMC chain:
cat( "Sampling final MCMC chain…\n" )
fit.mcmc<-coda.samples(jagsfit,variable.names=parameters,
                       n.iter=nPerChain, thin=thinSteps)

# duration of the run
end.time = Sys.time()
elapsed.time = difftime(end.time, start.time, units='mins')
cat("Sample analyzed after ", elapsed.time, ' minutes\n')
```

## Examine the results

```{r}
parameterstoplot=c("ALPHA","BETA","THETA[1]","THETA[2]","THETA[3]","SIGMA[1]","SIGMA[2]")
gelman.diag(fit.mcmc[,parameterstoplot])
summary(fit.mcmc)
```

```{r}
traceplot(fit.mcmc)
```

```{r}
densplot(fit.mcmc)
```

